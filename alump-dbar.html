<link rel="import" href="../polymer/polymer-element.html">

<!--
Distribution Bar element providing presentation of value distribution

Example:

    <alump-dbar values="[45,55]" texts="['yes,'no']" width="300"></alump-dbar>

@group alump Elements
@element alump-dbar
@demo demo/index.html
@hero hero.svg
-->
<dom-module id="alump-dbar">
  <template>
    <style>
       :host {
        display: block;
        user-select: none;
        padding: var(--alump-dbar-padding, 3px);
        overflow: hidden;
      }

      :host(.alump-r10) {
        --alump-dbar-border-radius: 10px;
      }

      :host(.alump-r20) {
        --alump-dbar-border-radius: 20px;
      }

      :host(.alump-shade) {
        --alump-dbar-border-style: groove;
        --alump-dbar-border-width: 2px;
        --alump-dbar-border-color: rgba(255, 255, 255, 0.3);
        --alump-dbar-text-color: rgba(255, 255, 255, 0.9);
      }

       :host .parts {
        overflow: visible;
        white-space: nowrap;
        box-sizing: border-box;
      }

      :host(.alump-shade) .parts .part {
        box-shadow: 0px 1px 5px rgba(0, 0, 0, 0.5), 0px 15px 5px rgba(255, 255, 255, 0.1) inset, 0px -10px 5px rgba(0, 0, 0, 0.05) inset;
      }

       :host .parts .part {
        display: inline-block;
        background-color: gray;
        margin: 0px;
        padding: 0.25em 10px;
        position: relative;
        box-sizing: border-box;
        border-width: var(--alump-dbar-border-width, none) 0px var(--alump-dbar-border-width, none) 0px;
        border-style: var(--alump-dbar-border-style, none);
        border-color: var(--alump-dbar-border-color, transparent);
      }

       :host(.alump-clickable) .parts .part {
        cursor: pointer;
      }

      :host(.alump-clickable) .parts .part:active {
        -webkit-filter: brightness(0.5);
        filter: brightness(0.5);
      }

       :host(.alump-shade.alump-clickable) .parts .part:hover {
        box-shadow: 0px 1px 5px rgba(0, 0, 0, 0.5), 0px 15px 5px rgba(255, 255, 255, 0.3) inset, 0px -10px 5px rgba(0, 0, 0, 0.2) inset;
      }

       :host .parts .part-0 {
        background-color: var(--alump-dbar-color0, #060);
      }

       :host .parts .part-1 {
        background-color: var(--alump-dbar-color1, #800);
      }

       :host .parts .part-2 {
        background-color: var(--alump-dbar-color2, #008);
      }

       :host .parts .part-3 {
        background-color: var(--alump-dbar-color3, #660);
      }

       :host .parts .part-4 {
        background-color: var(--alump-dbar-color4, #066);
      }

       :host .parts .part-5 {
        background-color: var(--alump-dbar-color5, #606);
      }

       :host .parts .part-6 {
        background-color: var(--alump-dbar-color6, #060);
      }

       :host .parts .part-7 {
        background-color: var(--alump-dbar-color7, #800);
      }

       :host .parts .part-8 {
        background-color: var(--alump-dbar-color8, #008);
      }

       :host .parts .part-9 {
        background-color: var(--alump-dbar-color9, #660);
      }

       :host .parts .part-10 {
        background-color: var(--alump-dbar-color10, #066);
      }

       :host .parts .part-11 {
        background-color: var(--alump-dbar-color11, #606);
      }

       :host .parts .part .text {
        display: inline-block;
        width: 100%;
        color: var(--alump-dbar-text-color, white);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        cursor: default;
        pointer-events: none;
        vertical-align: middle;
        text-align: var(--alump-dbar-text-align, left);
      }

      :host(.alump-shade) .parts .part .text {
        text-shadow: var(--alump-dbar-text-shadow, 0px 0px 2px rgba(0, 0, 0, 0.5));
      }

      :host .parts .part:first-child {
        border-left-width: var(--alump-dbar-border-width, none);
      }

      :host .parts .part:last-child {
        border-right-width: var(--alump-dbar-border-width, none);
      }

       :host .parts .part:first-child {
        border-top-left-radius: var(--alump-dbar-border-radius, 0px);
        border-bottom-left-radius: var(--alump-dbar-border-radius, 0px);
      }

       :host .parts .part:last-child {
        border-top-right-radius: var(--alump-dbar-border-radius, 0px);
        border-bottom-right-radius: var(--alump-dbar-border-radius, 0px);
      }

       :host(.alump-r20) .parts .part {
        padding-left: 15px;
      }

       :host .parts .part {
        transition: width var(--alump-dbar-animation-duration, 0.5s) linear;
        -webkit-transition: width var(--alump-dbar-animation-duration, 0.5s) linear;
      }
    </style>
    <div class="parts"></div>
  </template>

  <script>
    /**
     * `alump-dbar`
     * Distribution Bar
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class AlumpDbar extends Polymer.Element {
      /**
       * Element type
       * @return {string} alump-dbar
       */
      static get is() {
        return 'alump-dbar';
      }
      /**
       * Element properties
       * @return {object} properties object
       */
      static get properties() {
        return {
          /**
            * Values of parts
            */
          values: {
            type: Array,
            value: [0],
            observer: '_valuesChanged',
          },
          /**
          * Array of texts shown in parts. If undefined values are shown instead.
          */
          texts: {
            type: Array,
            value: undefined,
            observer: '_valuesChanged',
          },

          /**
          * Width of bar in pixels
          */
          width: {
            type: Number,
            value: null,
            observer: '_widthChanged',
          },

          /**
          * Minimum width of part in pixels
          */
          minPartWidth: {
            type: Number,
            value: 40,
            observer: '_minPartWidthChanged',
          },

          /**
          * Formatter method used to generate inner HTML for item
          */
          itemFormatter: {
            type: Function,
            value: (item) => {
              return (item) => {
                if (item.text) {
                  return item.text;
                } else {
                  return Math.round(item.value);
                }
              };
            },
            observer: '_itemFormatterChanged',
          },

          /**
          * Get number of parts defined
          */
          partCount: {
            type: Number,
            readOnly: true,
            computed: '_computePartCount()',
          },

          /**
          * Get sum of all values
          */
          valuesum: {
            type: Number,
            readOnly: true,
            computed: '_computeValueSum()',
          },
        };
      }

      /**
       * Observer for values
       */
      _valuesChanged() {
        this._scheduleRender();
      }

      /**
       * Observer for width
       */
      _widthChanged() {
        this._scheduleRender();
      }

      /**
       * Observer for minimal part width
       */
      _minPartWidthChanged() {
        this._scheduleRender();
      }

      /**
       * Observer for item formatter
       */
      _itemFormatterChanged() {
        this._scheduleRender();
      }

      /**
       * Private will schedule render
       */
      _scheduleRender() {
        if (Polymer.Debouncer) {
          this._renderDebouncer = Polymer.Debouncer.debounce(this._renderDebouncer,
            Polymer.Async.animationFrame, () => {
              this._render();
            });
        } else {
          this._render();
        }
      }

      /**
       * Private compute amout of values
       * @return {number} Amount of values
       */
      _computePartCount() {
        if (this.values) {
          return this.values.length;
        } else {
          return 0;
        }
      }

      /**
       * Private compute total sum of values
       * @return {number} Sum of values
       */
      _computeValueSum() {
        let sum = 0;
        if (this.values) {
          for (let i = 0; i < this.values.length; ++i) {
            let val = this.values[i];
            if (!isNaN(val) && val >= 0) {
              sum += val;
            }
          }
        }
        return sum;
      }

      /**
       * Private renderer, call via _scheduleRender
       */
      _render() {
        let partsElement = this.shadowRoot.querySelector('.parts');
        for (let i = partsElement.children.length; i < this.values.length; ++i) {
          let partElement = document.createElement('div');
          partElement.setAttribute('class', 'part part-' + i);
          partElement.addEventListener('click', function(e) {
            this._handlePartClick(e);
          }.bind(this));
          let textElement = document.createElement('div');
          textElement.setAttribute('class', 'text');
          partElement.appendChild(textElement);
          partsElement.appendChild(partElement);
        }
        while (partsElement.children.length > this.values.length) {
          let index = partsElement.children.length - 1;
          partsElement.removeChild(partsElement.children[index]);
        }

        let sum = this._computeValueSum();
        let pixelValue = 0;
        let myWidth = this.width;
        if (myWidth == null) {
          myWidth = partsElement.clientWidth;
        }
        if (sum != 0) {
          let availableSpace = myWidth - this.minPartWidth * this.values.length;
          pixelValue = availableSpace / sum;
        }

        for (let i = 0; i < this.values.length; ++i) {
          let partElement = partsElement.children[i];
          let value = this.values[i] > 0 ? this.values[i] : 0;
          if (sum == 0) {
            partElement.style.width = ''
              + (this.width / this.values.length)
              + 'px';
          } else {
            partElement.style.width = ''
              + (this.minPartWidth + value * pixelValue)
              + 'px';
          }

          let textElement = partElement.querySelector('.text');

          let item = {
            index: i,
            value: value,
          };
          if (this.texts && this.texts.length > i && this.texts[i]) {
            item.text = this.texts[i];
          }
          textElement.innerHTML = this.itemFormatter(item);
        }
      }

      /**
       * Private click handler
       * @param {event} e Original click event
       */
      _handlePartClick(e) {
        let partsElement = this.shadowRoot.querySelector('.parts');
        let partElements = partsElement.childNodes;
        for (let i = 0; i < partElements.length; ++i) {
          if (partElements[i] == e.target) {
            let value = this.values[i];
            let text = this.texts === undefined ? undefined : this.texts[i];
            this.dispatchEvent(new CustomEvent('partclick', {
              detail: {
                'part': i,
                'value': value,
                'text': text,
                'event': e,
              },
              bubbles: true,
            }));
            return;
          }
        }
      }
    }

    window.customElements.define(AlumpDbar.is, AlumpDbar);
  </script>
</dom-module>